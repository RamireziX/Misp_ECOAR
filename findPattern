#ecoar misp project
#search for a pattern 
#black  & white image

#[most sig bit][][][][][][][][][][][least sig bit]
#pass pointer to structure imgInfo(width, height, pointer to where the buffer of image is located, X & Y coordinates)
#possible to store pattern in registers
#compare masked bytes 

#open file->read whole content at once(will also get info about length of file when reading)

# 62 - bmp file header size


  
  .data
fname:  .asciiz "src_001.bmp"

imgInfo:
w:	.word 32
h:	.word 32
pImg:	.word 0
wbytes:	.word 32
fsize:	.word -1

analyze_data:					.word 	0,0,0,0,0,0,0,0
start_lines:					.word	0,0,0,0,0,0,0,0
next_byte_to_read_per_line:		.word	0,0,0,0,0,0,0,0
		

ptrn:
	.byte 0, 0, 0, 0, 0, 0, 0, 0
pResult:
	.space 100	
fbuf: 
	.space 44000

  .text
  
main:

 	la 	$a0, fname
 	li 	$a1, 0
 	li 	$a2, 0
 	li	$v0, 13 		#open file read only
 	syscall
  
  	move 	$a0, $v0
  	la 	$a1, fbuf
  	li 	$a2, 44000
  	li 	$v0, 14   		#read file
  	syscall
  
  	li	 $v0, 16		#close the file
  	syscall
  
  	la	 $s0, fbuf

  	
 
 #s0 - poczatek danych 
 
#Point* FindPattern(imgInfo* pImg, int pSize, int* ptrn, Point* pResult);
 
 	li	$t1, 5			#sx
 	li	$t2, 6 			#sy
 	sll	$t1, $t1, 8
 	or	$t1, $t1, $t2
 
 	la	$a0, pImg
 	move	$a1, $t1
 	la	$a2, ptrn
 	la	$a3, pResult
 	
 	jal	FindPattern

end:
  	li $v0, 10		#end program
  	syscall
  
#a0 - imgInfo* pImg
#a1 - pSize
#a2 - pattern
#a3 - table where coordinates will be stored

FindPattern:
	sub 	$sp, $sp, 4		#push $ra to the stack
	sw 	$ra, 4($sp)
	
	#addiu 	$sp, $sp, -32		#room on stack for workspace
	
	#addiu	$sp, $sp, -32		#room for addrresses
	
	
	move	$s0, $a0
	#get filesize
  
  	lbu	$t0, 2($s0)
  	lbu 	$t1, 3($s0)
  	lbu 	$t2, 4($s0)
  	lbu	$t3, 5($s0)
 
  	sll 	$t1, $t1, 8
  	sll 	$t2, $t2, 16
  	sll 	$t3, $t3, 24
 
  	or 	$t3, $t3, $t2
  	or 	$t3, $t3, $t1
  	or 	$t3, $t3, $t0
 
  	sw	$t3, fsize

  	#get width

  	lbu 	$t0, 18($s0)
  	lbu 	$t1, 19($s0)
  	lbu 	$t2, 20($s0)
  	lbu 	$t3, 21($s0)

 
  	sll	$t1, $t1, 8
  	sll 	$t2, $t2, 16
  	sll 	$t3, $t3, 24
 
  	or 	$t3, $t3, $t2
  	or 	$t3, $t3, $t1
  	or 	$t3, $t3, $t0

  	sw	$t3, w
  
 	#get height 
 
  	lbu 	$t0, 22($s0)
  	lbu 	$t1, 23($s0)
  	lbu 	$t2, 24($s0)
  	lbu 	$t3, 25($s0)
 
  	sll 	$t1, $t1, 8
  	sll 	$t2, $t2, 16
  	sll 	$t3, $t3, 24
 
  	or 	$t3, $t3, $t2
  	or 	$t3, $t3, $t1
  	or 	$t3, $t3, $t0
 
  	sw	$t3, h
  
  
 shift:
  	lbu 	$t0, 10($s0)
  	lbu 	$t1, 11($s0)
  	lbu 	$t2, 12($s0)
  	lbu 	$t3, 13($s0)

  	sll 	$t1, $t1, 8
 	sll 	$t2, $t2, 16
  	sll 	$t3, $t3, 24
 
  	or 	$t3, $t3, $t2
  	or 	$t3, $t3, $t1
  	or 	$t3, $t3, $t0
 
  	addu 	$s0, $s0, $t3			#move to the start of bitmap
#s0 - poczatek bitmapy
 
 widthBytes:
  	lw		$t0, w
  	addiu 	$t0, $t0, 7
  	srl 	$t0, $t0, 3
  	addiu 	$t0, $t0, 3
  	srl 	$t0, $t0, 2
  	sll		$t0, $t0, 2
 
  	sw 		$t0, wbytes
	
	move	$t1, $s0

#t1 - adres poczatku wiersza
#t2 - wysokosc wzorca
#t3 - gdzie zapisujemy dane
	

	move	$t2, $a1
	andi	$t2, 0x000000FF
	move	$s7, $t2																					##$s7 - wysokosc wzorca, nie ruszac
	
	move	$t1, $a1
	srl		$t1, $t1, 8
	andi	$t1, 0x000000FF
	move	$s6, $t1
	
	
	## s6 - szerokoc wzorca

	
	move	$t9, $zero
	li		$t8, 1
	sll		$t8, $t8, 15
	move	$t7, $s6
	
	
build_mask:	
	or		$t9, $t9, $t8
	srl		$t8, $t8, 1
	subiu	$t7, $t7, 1
	bgtz	$t7, build_mask
	
	move	$s5, $t9														## s5 - maska
	

#start_lines - adresy poczatku linii
#analyze_data - zrzut rejestru
#next_byte_to_read_per_line - naste
	
	la	$t3, start_lines
	move	$t1, $s0
	
zapisz_poczatki_linii:
	sw			$t1, ($t3)
	addiu		$t3, $t3, 4
	addu		$t1, $t1, $t0							#adres poczatku kolejnego wiersza
	sub			$t2, $t2, 1
	bgtz		$t2, zapisz_poczatki_linii
	
	
	
	
	
	la			$t3, start_lines
	la			$t5, analyze_data
	move		$t6, $s7
	la			$t7, next_byte_to_read_per_line
	

store_data:	
	lw			$t1, ($t3)								#t1 - poczatek wiersza 
	addiu		$t3, $t3, 4
	
	move		$t4, $zero
	
	lbu			$t4, 0($t1)
	addiu		$t1, $t1, 1

	sll			$t4, $t4, 8

	lbu			$t4, ($t1)
	addiu		$t1, $t1, 1
	
	sw			$t4, ($t5)
	sw			$t1, ($t7)
	
	
	addiu		$t5, $t5, 4
	addiu		$t7, $t7, 4
	
	subiu		$t6, $t6, 1
	bgtz		$t6, store_data
	
	
	
	
	
	
#	t4 - licznik w poziomie
	lw			$t4, w
	sub			$t4, $t4, $s6
	addiu		$t4, $t4, 1
	
	
	
	
	la			$t3, start_lines
	la			$t7, next_byte_to_read_per_line
	li			$t9, 0		
	move		$t8, $s7
	move		$s4, $a2
	move		$t2, $s7												#zliczanie wysokosci
	
	li			$s3, 1
	
kolejna_linia:
	#zwiekszenie wartosci





	
	
	
poziomo:																#
	addiu		$t9, $t9, 1
	andi		$t9, $t9, 0x00000007
	
	subiu		$t4, $t4, 1
	
	
	la			$t5, analyze_data
	


pionowo:

	lw			$t6, ($t5)												#wczytanie dla i-tego wiersza
	move		$t0, $t6												#t0 - tu bedzie wynik maskowania
	
	#
	sll			$t6, $t6, 1
 
	bgtz		$t9, nie_wczytuj_bajtu
wczytaj_kolejny_bajt:
	lw			$s2, ($t7)
	lbu			$t6, ($s2)
	addiu		$s2, $s2, 1
	sw			$s2, ($t7)
	addiu		$t7, $t7, 1
	
nie_wczytuj_bajtu:	
	sw			$t6, ($t5)
	addiu		$t5, $t5, 1												#przesuniecie adresu dla kolejnego wiersza
	
	beqz		$s3, nie_maskowanie
maskowanie:
	and			$t0, $t0, $s5
	srl			$t0, $t0, 8
	lbu			$t1, ($s4)
	beq			$t0, $t1, nie_maskowanie
niepasuje:	
	li			$s3, 0
nie_maskowanie:

	addiu		$s4, $s4, 1
	subiu		$t2, $t2, 1
	
	bgtz		$t2, pionowo
	
#tu przeszlismy caly wzorzec pionowo
	beqz		$s3, poziomo
	
	
	bgtz		$t4, poziomo
	
	
#ponownie wczytac $t4	
	
	
	
	
	
	
	
	
	
zapis:
	



	
	
	
	
	
	
	
	

	
	
#t2
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	lw 		$ra, 4($sp)		#restore (pop) $ra
	add 	$sp, $sp, 4
	jr 		$ra







	
