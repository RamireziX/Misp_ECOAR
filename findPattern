#ecoar misp project
#search for a pattern 
#black  & white image

#[most sig bit][][][][][][][][][][][least sig bit]
#pass pointer to structure imgInfo(width, height, pointer to where the buffer of image is located, X & Y coordinates)
#possible to store pattern in registers
#compare masked bytes 

#open file->read whole content at once(will also get info about length of file when reading)

# 62 - bmp file header size


  
  .data
fname:  .asciiz "src_001.bmp"
fnameout:  .asciiz "src_002.bmp"

imgInfo:
w:	.word 32
h:	.word 32
pImg:	.word 0
wbytes:	.word 32
fsize:	.word -1

analyze_data:					.word 	0,0,0,0,0,0,0,0
start_lines:					.word	0,0,0,0,0,0,0,0
next_byte_to_read_per_line:		.word	0,0,0,0,0,0,0,0
		

ptrn:
	.byte 0, 0, 0, 0, 0, 0, 0, 0
pResult:
	.space 1024	
fbuf: 
	.space 44000

  .text
  
main:

 	la 	$a0, fname
 	li 	$a1, 0
 	li 	$a2, 0
 	li	$v0, 13 		#open file read only
 	syscall
  
  	move 	$a0, $v0
  	la 	$a1, fbuf
  	li 	$a2, 44000
  	li 	$v0, 14   		#read file
  	syscall
  
  	li	 $v0, 16		#close the file
  	syscall
  
  	la	 $s0, fbuf

  	
 
 #s0 - poczatek danych 
 
#Point* FindPattern(imgInfo* pImg, int pSize, int* ptrn, Point* pResult);
 
 	li	$t1, 5			#sx
 	li	$t2, 6 			#sy
 	sll	$t1, $t1, 8
 	or	$t1, $t1, $t2
 
 	la	$a0, fbuf
 	move	$a1, $t1
 	la	$a2, ptrn
 	la	$a3, pResult
 	
 	jal	FindPattern
	
	
	move		$s0, $v0
	move		$s1, $v1
	
	
	move		$a0, $s1
	li			$v0, 1
	syscall
	
	li			$a0, 10
	li			$v0, 11
	syscall
	
#	lw			$a0, ($s0)
#	li			$v0, 1
#	syscall
	
	li			$a0, 10
	li			$v0, 11
	syscall
	
	add			$s0, $s0, 4
	
	
#	lw			$a0, ($s0)
#	li			$v0, 1
#	syscall
	
	li			$a0, 10
	li			$v0, 11
	syscall
	
	la 	$a0, fnameout
 	li 	$a1, 1		#open file read only
 	li 	$a2, 0
 	li	$v0, 13 		
 	syscall
	
	
	
	move 	$a0, $v0
  	la 	$a1, fbuf
  	li 	$a2, 44000
  	li 	$v0, 15   		#save file
  	syscall
	
	
	
	
	

end:
  	li $v0, 10		#end program
  	syscall
  
#a0 - imgInfo* pImg
#a1 - pSize
#a2 - pattern
#a3 - table where coordinates will be stored

FindPattern:
	sub 	$sp, $sp, 4		#push $ra to the stack
	sw 	$ra, 4($sp)
	
	#addiu 	$sp, $sp, -32		#room on stack for workspace
	
	#addiu	$sp, $sp, -32		#room for addrresses
	
	
	move	$s0, $a0
	#get filesize
  
  	lbu	$t0, 2($s0)
  	lbu 	$t1, 3($s0)
  	lbu 	$t2, 4($s0)
  	lbu	$t3, 5($s0)
 
  	sll 	$t1, $t1, 8
  	sll 	$t2, $t2, 16
  	sll 	$t3, $t3, 24
 
  	or 	$t3, $t3, $t2
  	or 	$t3, $t3, $t1
  	or 	$t3, $t3, $t0
 
  	sw	$t3, fsize

  	#get width

  	lbu 	$t0, 18($s0)
  	lbu 	$t1, 19($s0)
  	lbu 	$t2, 20($s0)
  	lbu 	$t3, 21($s0)

 
  	sll	$t1, $t1, 8
  	sll 	$t2, $t2, 16
  	sll 	$t3, $t3, 24
 
  	or 	$t3, $t3, $t2
  	or 	$t3, $t3, $t1
  	or 	$t3, $t3, $t0

  	sw	$t3, w
  
 	#get height 
 
  	lbu 	$t0, 22($s0)
  	lbu 	$t1, 23($s0)
  	lbu 	$t2, 24($s0)
  	lbu 	$t3, 25($s0)
 
  	sll 	$t1, $t1, 8
  	sll 	$t2, $t2, 16
  	sll 	$t3, $t3, 24
 
  	or 	$t3, $t3, $t2
  	or 	$t3, $t3, $t1
  	or 	$t3, $t3, $t0
 
  	sw	$t3, h
  
  
 shift:
  	lbu 	$t0, 10($s0)
  	lbu 	$t1, 11($s0)
  	lbu 	$t2, 12($s0)
  	lbu 	$t3, 13($s0)

  	sll 	$t1, $t1, 8
 	sll 	$t2, $t2, 16
  	sll 	$t3, $t3, 24
 
  	or 	$t3, $t3, $t2
  	or 	$t3, $t3, $t1
  	or 	$t3, $t3, $t0
 
  	addu 	$s0, $s0, $t3			#move to the start of bitmap
#s0 - poczatek bitmapy
 
 widthBytes:
  	lw		$t0, w
  	addiu 	$t0, $t0, 7
  	srl 	$t0, $t0, 3
  	addiu 	$t0, $t0, 3
  	srl 	$t0, $t0, 2
  	sll		$t0, $t0, 2
 
  	sw 		$t0, wbytes
	
	move	$t1, $s0

#t1 - adres poczatku wiersza
#t2 - wysokosc wzorca
#t3 - gdzie zapisujemy dane
	

	move	$t2, $a1
	andi	$t2, 0x000000FF
	move	$s7, $t2																					##$s7 - 
	
	move	$t1, $a1
	srl		$t1, $t1, 8
	andi	$t1, 0x000000FF
	move	$s6, $t1
	
	
	## s6 - szerokoc wzorca

	
	move	$t9, $zero
	li		$t8, 1
	sll		$t8, $t8, 15
	move	$t7, $s6
	
	
build_mask:	
	or		$t9, $t9, $t8
	srl		$t8, $t8, 1
	subiu	$t7, $t7, 1
	bgtz	$t7, build_mask
	
	move	$s5, $t9														

#a0 - wolne
#a1 - licznik punktow
#a2 - pattern
#a3 - adres potencjalnego punktu

#t0 - wynik maskowania
#t1 - temp
#t2 - 
#t3 - 
#t4 - licznik pikseli w poziomie
#t5 - 
#t6 - 
#t7 - 
#t8 - pole szukania pionowo
#t9 - 

#s0 - 
#s1 - 
#s2 - 
#s3 - 
#s4 - 
#s5 - maska, stala
#s6 - szerokosc wzorca, nie ruszac
#s7 - wysokosc wzorca, nie ruszac




	
	
## s5 - maska
	

#start_lines - adresy poczatku linii
#analyze_data - zrzut rejestru
#next_byte_to_read_per_line - naste
	
	la	$t3, start_lines
	move	$t1, $s0
	
zapisz_poczatki_linii:
	sw			$t1, ($t3)
	addiu		$t3, $t3, 4
	addu		$t1, $t1, $t0							#adres poczatku kolejnego wiersza
	sub			$t2, $t2, 1
	bgtz		$t2, zapisz_poczatki_linii
	
	
	
	
	
	la			$t3, start_lines						#istnieje 
	la			$t5, analyze_data						
	move		$t6, $s7
	la			$t7, next_byte_to_read_per_line			#adres
	

store_data:	
	lw			$t1, ($t3)								#t1 - poczatek wiersza 
	
	
	addiu		$t3, $t3, 4
	
	move		$t4, $zero
	
	lbu			$t4, 0($t1)
	addiu		$t1, $t1, 1

	sll			$t4, $t4, 8

	lbu			$t4, ($t1)
	addiu		$t1, $t1, 1
	
	sw			$t4, ($t5)
	sw			$t1, ($t7)
	
	
	addiu		$t5, $t5, 4
	addiu		$t7, $t7, 4
	
	subiu		$t6, $t6, 1
	bgtz		$t6, store_data
	
	
	
	
#a1 - 
#t4 - licznik w poziomie
#t9 - licznik w pionie


	lw			$t4, w
	sub			$t4, $t4, $s6
	addi		$t4, $t4, 1
	
	move		$t9, $zero
	subi		$t9, $t9, 1
	
	
	la			$t3, start_lines
	la			$t7, next_byte_to_read_per_line	
	
	move		$t2, $s7												#zliczanie wysokosci, wzorca
	

#ustalenie wysokosci przeszukiwania	
	lw			$t8, h
	subu		$t8, $t8, $s7
	addiu		$t8, $t8, 1
	
	move		$v1, $zero
	

	
kolejna_linia:
	#zwiekszenie wartosci

	addi		$t9, $t9, 1					#
	move		$a1, $zero					#a1 - licznik pikseli w prawo, od 0	
	
	
poziomo:		#przesuniecie okna porownania w prawo o 1 piksel
	
	la			$t5, analyze_data			
	la			$t7, next_byte_to_read_per_line
	
	
	
	
	move		$s4, $a2												#ustawienie na poczatek paterna
	li			$s3, 1
	
	

	
pionowo:

	lw			$t6, ($t5)												#wczytanie dla i-tego wiersza
	move		$t0, $t6												#t0 - tu bedzie wynik maskowania
	
	#
	sll			$t6, $t6, 1
 
 

 
 	move		$s2, $a1
	andi		$s2, $s2, 0x00000007
	bne			$s2, 0x00000007, nie_wczytuj_bajtu
	#j			nie_wczytuj_bajtu
#wczytaj_kolejny_bajt:
	#addiu		$t7, $t7, 4
	lw			$s2, ($t7)
	
	lbu			$t6, ($s2)
	move		$t6, $zero
	sb			$t6, ($s2)
	

	addiu		$s2, $s2, 1
	sw			$s2, ($t7)
	addiu		$t7, $t7, 4
	
	
	
	
	
	
	#j 			enddddddddddddddddddddddddd
	
nie_wczytuj_bajtu:	
	sw			$t6, ($t5)
	addiu		$t5, $t5, 4												#przesuniecie adresu dla kolejnego wiersza
	
	beqz		$s3, nie_maskowanie
maskowanie:
	and			$t0, $t0, $s5
	lbu			$t1, ($s4)
	sll			$t1, $t1, 8
	and			$t1, $t1, $s5

	
	
	
	
	
	
	beq			$t0, $t1, nie_maskowanie

#niepasuje:	
	move		$s3, $zero
nie_maskowanie:

	addi		$s4, $s4, 1
	subi		$t2, $t2, 1
	
	bgtz		$t2, pionowo
	
	move		$t2, $s7
	
	
	
	#j			enddddddddddddddddddddddddd
	
	#la			$t7, next_byte_to_read_per_line
	
#tu przeszlismy caly wzorzec pionowo
	beqz		$s3, test_poziomo
zapisz_punkt:
#a3 - 
	#sw			$a1, ($a3)
	addiu		$a3, $a3, 4
	
	#sw			$t9, ($a3)
	addiu		$a3, $a3, 4
	
	addiu		$v1, $v1, 1
	
test_poziomo:	

	#la			$t7, next_byte_to_read_per_line			
	
	addiu		$a1, $a1, 1
	#blt			$a1, $t4, poziomo
	blt		$a1, 700, poziomo
	
#ponownie wczytac $t4




	#blt			$t9, $t8, kolejna_linia
	
	la			$v0, pResult
	
enddddddddddddddddddddddddd:
	lw 		$ra, 4($sp)		#restore (pop) $ra
	add 	$sp, $sp, 4
	jr 		$ra







	
